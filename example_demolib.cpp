#include "demolib.h"

// Include looptools to call setlambda()
// in order to get divergent contributions
#include "clooptools.h"

using namespace demolib;

int main() {


    // Initialize the model parameters
    param_t params;

    double alpha = 1./137;
    double m = 0.1;
    params.e = std::sqrt(4*M_PI*alpha);
    params.m_mu = m;


    /////////////////////////////////////////
    /////////////////////////////////////////
    //  Calculate the muon self-energy
    /////////////////////////////////////////
    /////////////////////////////////////////

    // s_11 required by the function but irrelevant
    params.s_11 = 0; // = p*p, irrelevant when taking divergent part

    // Consider the divergent contributions
    setlambda(-1);     // Tell looptools to get coef of 1/eps
    params.Finite = 0; // Remove finite local terms

    // Compare values w.r.t M. Schwartz' book (M.S.) p. 327 eq. 18/13
    //
    // Convention differences:
    //   - M.S. multiplies the amplitude by -i to obtain the contrib 
    //   while MARTY multiplies amplitudes by i when extracting
    //   coefficients --> -1 in the absolute factor
    //   - M.S. uses dim. reg. D = 4 - eps while LoopTools (and consequently
    //   MARTY) uses dim. reg. D = 4 - 2*eps --> 2 in the absolute factor
    //
    // The result of M.S. must be multiplied by -1/2 to match MARTY's 
    // conventions

    // Call the functions generated by MARTY
    double C_m = mu_self_e_mterm(params).real();
    double C_p = mu_self_e_pterm(params).real();

    std::cout << "######################################\n";
    std::cout << "####  MUON SELF-ENERGY\n";
    std::cout << "######################################\n\n";
    std::cout << "Values for the m and pslash coefficients:\n";
    std::cout << "C_m = " << C_m << std::endl;
    std::cout << "C_p = " << C_p << std::endl;
    std::cout << std::endl;

    std::cout << "Check the relative factor:\n";
    std::cout << "-4m*C_p = " << -4*m*C_p << std::endl;
    std::cout << "(should be equal to C_m = " << C_m << ")\n\n";

    std::cout << "Check the absolute factor:\n";
    std::cout << C_p << std::endl;
    std::cout << "(should be equal to " << -alpha / (4 * M_PI) << ")" << std::endl;
    std::cout << std::endl;


    /////////////////////////////////////////
    /////////////////////////////////////////
    //  Calculate the muon anomalous
    //  magnetic moment (g-2)
    /////////////////////////////////////////
    /////////////////////////////////////////
    
    // Compare values with p. 320 eq 17.32
    //
    // To obtain (g-2), considering MARTY already multiplied
    // the amplitude by i, we can get (g-2) by multiplying
    // the coefficient of MARTY by -8m/e
    
    std::cout << "######################################\n";
    std::cout << "####  MUON ANOMALOUS MAGNETIC MOMENT\n";
    std::cout << "######################################\n\n";
    // Kinematical variable s_12 for mu -> mu gamma
    params.s_12 = m*m;
    // Do not forget to set finite contributions for (g-2) !
    params.Finite = 1;
    setlambda(0);

    // Finally calculate (g-2)µ
    double C_mag = mu_magnetic_vertex(params).real();
    double C_mag_eval = mu_magnetic_vertex_eval(params).real();
    double C_mag_simpli = mu_magnetic_vertex_simpli(params).real();
    std::cout << "(g-2)µ               = " << -8*m/params.e * C_mag << std::endl;
    std::cout << "(g-2)µ  [evaluated]  = " << -8*m/params.e * C_mag_eval << std::endl;
    std::cout << "(g-2)µ  [simplified] = " << -8*m/params.e * C_mag_simpli << std::endl;
    std::cout << "Theoretical result   = " << alpha/M_PI << " ( = alpha/pi)" << std::endl;
    
    return 0;
}
